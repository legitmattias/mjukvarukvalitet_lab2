# Mina reflektioner

Projekt: Mjukvarukvalitet Laboration 2
Datum: 2024-10-02
Name: Mattias Ubbesen <mu222cu@student.lnu.se>

## Allmänna reflektioner kring arbetet och OOP

### Bakgrund

Efter att ha funderat över lite olika alternativ bestämde jag mig för att skapa en Markdown Parser som hämtar ut relevant data ur README-filer på Github, Gitlab och liknande repositorier. Anledningen var att jag ville hitta en modulidé som var tillräckligt nischad för att ha en USP, eller åtminstone inte konkurrera med stora välkända bibliotek, och samtidigt vara tillräckligt generell för att fungera som en användbar modul i någon annans kodbas.

Tillvägagångssättet var så att jag började med att studera hur readme-filer är strukturerade och vilka rubriker som används. För att automatisera det här skrev jag ett skript som hade kapaciteten att hämta hem stora mängder readme-filer, men pga tidsbrist så blev det ändå ett ganska manuellt arbete att få ett hum om vad jag skulle rikta in mig på.

När jag väl började koda var det självklara första steget att skapa en enkel markdown parser, och det blev genast uppenbart att denna parser bör vara generell och inte kopplad till någon specifik kontext, bortsett från filtypen i sig och att den är uppbyggd av rubriker och avsnitt. Här föddes också idén om att kunna koppla enskilda (eller flera) kontexter till den generella parsern, dvs specialiserade klasser med sin egen logik och api. Dessa kontexter kallar jag för *Processors* för att de extraherar och processar data snarare än agerar som parser.

### Ett bibliotek växer fram

Mycket av min tid i det här projektet har, förutom att skapa fungerande linter- och formatteringskonfigurationer, lagts på att fundera över hur de olika klasserna ska förhålla sig till varandra och vara beroende av varandra. Jag har till det yttersta eftersträvat inkapsling, "information-hiding" och modularitet. Jag la nästan en dag på förhållandet mellan MarkdownParser och kontextklasserna. Min tanke var att användaren med hjälp av "dependency injection" instansiera en kontext med en valfri parser, för att på så vis få till en "lose coupling" mellan klasserna: `RepiReadmeProcessor(<Readme-file>, <Parser)`. Men hur jag än gjorde blev det bara onödigt stökigt, där dels användaren skulle behöva instansiera i flera steg fastän jag ändå inte tillhandahåller mer än en enskild parser, som dessutom är generell, och dels skulle jag behöva delegera generella publika metoder från parsern till kontexten, vilket är ett otyg. Därefter funderade jag på att använda ett "proxy pattern" där anrop mot generella publika metoder skulle skickas till parsern om de inte hittades i kontexten. Ett annat alternativ var att använda mig av "strategy pattern", vilket visserligen skulle göra allt än mer flexibelt för användaren, men bra mycket mer komplext helt i onödan. Jag valde slutligen att använda mig av arvshierarkier, vilket trots att det innebär en "tight coupling" ändå kändes som det enklaste och mest fruktbara alternativet när kontexter ändå är skapade för att utvidga parserns generella förmågor. inte att vara ett komplement.

Efter hand börjar projektet svälla. Jag skapar *HeadingDictionaries* som är en sorts lookup-tables för att förfina sökning i rubriker, men också göra det mycket mer flexibelt och modulärt: dels genom att kunna modifiera befintliga dictionaries, dels genom att kunna skicka in sin egna custom dictionary. Jag får en idé om att processa Npm-readmes, vilka jag snart inser har mer likheter än skillnader mot Github-readmes. Det naturliga då är att jag låter Npm-kontexten ärva från Repo-kontexten, vilket skapar ett bekymmer med flera nivåer av hantering av dictionaries som måste hanteras. Det har varit kul och jag ångrar egentligen inte vägen jag valt, men med tanke på den begränsade tid som fanns att tillgå hade det kanske varit bättre om jag lyckats avgränsa mig mer och fokusera mer på färre delar. Men jag tycker ändå att jag har fått ihop det helt ok utan att det spretar för mycket, även om det så klart finns mycket mer man kan göra kring felhantering, fler tester och än mer användbart api. Genom att skapa tre kontexter till min parser kan jag visa att den fungerar att utvidga såväl horisontellt som vertikalt eftersom varje kontext har gemensam logik och det bara är api:erna och eventuella hjälpfunktioner som skiljer. 

### Migrering till Typescript

Att jag valde Javascript som språk har mest att göra med att jag kände mig mest bekväm med det när vi drog igång, och jag tror att jag snabbare kunde skapa relevant resultat för webbinriktade applikationer. Men samtidigt har det redan från start känts som ett dåligt val i en kurs som har mycket fokus på objektorienterad programmering och "Clean code" med tillhörande dokumentation. Det jag framförallt har saknat är striktare hantering av typer.  Halvvägs in i projektet valde jag följaktligen att migrera min kod till Typescript, vilket jag inte har någon större erfarenhet av. Även om det innebar ytterligare lite tid som lades på annat än kodning så ångrar jag inte en sekund. Att ha tillgång till en typsäkerhet i kombination med en mer utvecklad "information hiding" inom och mellan klasser har varit till fördel i det här projektet. Jag förutsätter att Typescript är godkänt språk att använda då det snarare är en striktare variant av Javascript med statisk typning, vilket inte borde vara något främmande då alla i utbildningen även har läst Java.

## Reflektioner kring Clean code och kodkvalitetskrav

Det finns några enskilda delar som jag tydligt har försökt jobba extra mycket på under den här laborationen, även om jag inte alls har kommit helt i mål på grund av den begränsade tidsrymden.
1. OOP: Tydligt arbeta med ansvarsfördelning, inkapsling, och information hiding. Jag tycker att jag har lyckats relativt bra med att separera de olika ansvarsområdena inom olika klasser, och ren data så som dictionaries och mock-data har jag hållit utanför klasserna.
2. Små funktioner med en uppgift: Det finns säkerligen mer att göra här men jag har ändå lyckats dela upp vissa metoder som annars skulle ha varit större och mer komplexa.
3. Namngivning: Jag har försökt namnge samtliga metoder och klasser så att de är självbeskrivande och intuitiva. Men ibland är det svårt att hitta rätt balans mellan att ge information i namnet och lova nåt som inte stämmer, t.ex. att data ska returneras men att det inte är garanterat den sortens data.
4. Kommentarer: Jag skrev mest inline-kommentarer först. Jag förstår poängen med att man inte ska skriva kommentarer för sakens skulle, och framförallt inte kommentarer som inte hjälper, utan i värsta fall stjälper. Men jag valde att lägga till JSdocs på alla klasser och metoder, och det av den enkla anledningen att det är mer strukturerat och för att det finns verktyg som både kan analysera och sammanfatta kod utifrån JSdocs.

## 5 identifierare och hur de relaterar till Clean code

| Namn och förklaring                                                                                                                      | Reflektion och regler från Clean Code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `getSectionWithTemplate()`<br><br>En "template method"-metod för att systematiskt återanvända logik för publika metoder som är snarlika. | Den här stämmer överens med regeln att använda *verb för metodnamn*. Namnet avslöjar hyfsat tydligt vad metoden gör: nyttjar en mall för att hämta avsnitt ur dokumentet.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `getUpdatesBetweenVersions()`<br><br>En metod som hämtar avsnitt mellan två angivna versionsnamn.                                        | Den här metoden är *beskrivande* och lätt att förstå, inte minst för andra utvecklare, och i synnerhet de som har erfarenhet av changelogs eller versionshantering i allmänhet.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `getSectionByKeywords()` (`findSectionByKeywords()`)<br><br>Metod för att hämta avsnitt utifrån angivet nyckelord.                       | Den här metoden tar jag med som exempel på *Consistency*. Dels för att jag använder get-prefix konsekvent för de metoder som returnerar en särskild resurs, men dels också för att den här först hade ett annat namn som inte var konsekvent med andra liknade metoder då den hade prefixet *find*. Det var dock inte självklart att det alltid ska vara *get*, eftersom det kan framstå som mer instrumentellt "hämtande", medan "find" antyder ett mer förutsättningslöst "sökande".<br><br>Möjligen skulle man kunna lägga till mer information i namnet, `getSectionByKeywordsInHeading()`, men det känns inte nödvändigt då modulen/biblioteket nästan uteslutande riktar in sig på rubriker och är därmed underförstått för användaren. |
| `titleAndDescription()`<br><br>Metod som returnerar ett dokuments titel och beskrivning.                                                 | I det här fallet tänker jag att metodnamnet kan symboliserar frånvaron av 'Noise', då den är enkel, tydlig och inte innehåller några onödiga ord som "data" eller "info".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `NpmReadmeProcessor`<br><br>En klass som hanterar readme-filer i Npm.                                                                    | Som exempel på att klasser bör namnges som *substantiv*. Namnet i sig är också tydligt och informativt. Jag har ändrat namn på både klasser och biblioteket i sin helhet några gånger just för att hitta så självbeskrivande namn som möjligt, samtidigt som de är koncisa. Från början hette mina Processor-klasser "Parsers", men jag                                                                                                                                                                                                                                                                                                                                                                                                       |

